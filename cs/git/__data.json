{"type":"data","nodes":[null,{"type":"data","data":[{"prev":1,"next":4,"section":7},{"slug":2,"title":3},"cs\u002Fcheminfomatics","Cheminfomatics",{"slug":5,"title":6},"cs\u002Fremote","Remote",{"file":8,"title":9,"date":10,"summary":-1,"tag":11,"toc":13,"body":14},"cs\u002F17-git.md","Git 사용법","June 6, 2020",[12],"linux","\u003Ch4\u003EContents\u003C\u002Fh4\u003E\u003Cp class=\"toc-h2\"\u003E\u003Ca href=\"#git-manual\"\u003EGit Manual\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp class=\"toc-h2\"\u003E\u003Ca href=\"#하나의-컴퓨터local-machine에서-다중-user를-이용한-github-작업-수정-중\"\u003E하나의 컴퓨터(local machine)에서 다중 User를 이용한 github 작업. (수정 중)\u003C\u002Fa\u003E\u003C\u002Fp\u003E","\u003Ch2 id=\"git-manual\"\u003EGit Manual\u003Ca href=\"#git-manual\" class=\"anchor\"\u003E\u003Cspan class=\"visually-hidden\"\u003E#\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\u003Cp\u003EGit은 3가지 요소로 구성이 되어 있다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E작업 트리(working tree or working directory) - Directory 자체를 의미한다.\u003C\u002Fli\u003E\n\u003Cli\u003E스테이지(stage) - git 상에 추가된 파일들을 의미한다. (.git\u002Findex)\u003C\u002Fli\u003E\n\u003Cli\u003E저장소(repository) - commit 되어 버전으로 남은 것들을 의미한다. (.git\u002FHEAD)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Ccode\u003Egit commit --amend\u003C\u002Fcode\u003E: 방금 commit한 메세지 수정이 필요할때\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit status\u003C\u002Fcode\u003E: 현재의 상태\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit log [--oneline] [--branches] [--graph]\u003C\u002Fcode\u003E: 저장소 log\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit diff\u003C\u002Fcode\u003E: \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit checkout -- &lt;paths&gt;\u003C\u002Fcode\u003E: 작업 트리에서 수정한 파일 되돌리기\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit reset &lt;tree-ish&gt; &lt;paths&gt;\u003C\u002Fcode\u003E: 기존 commit을 제거하고 돌아감.\u003Cbr\u003E(\u003Ccode\u003EHEAD^^\u003C\u002Fcode\u003E 현재 HEAD에서 전전을 의미함.)\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit revert &lt;tree-ish&gt;\u003C\u002Fcode\u003E: 기존 commit을 놔두고 새로운 commit을 만듦.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit branch &lt;branchname&gt;\u003C\u002Fcode\u003E: branchname으로 새로운 branch 생성.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit checkout &lt;branch&gt;\u003C\u002Fcode\u003E: 해당 branch로 설정.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit log &lt;path&gt;..&lt;path&gt;\u003C\u002Fcode\u003E*: \u003Cdel\u003E아직 잘 모르겠음.\u003C\u002Fdel\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit merge &lt;branch&gt;\u003C\u002Fcode\u003E: 현재 HEAD에 해당 branch를 합친다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit stash [list|pop|apply|drop]\u003C\u002Fcode\u003E: 수정된 파일들을 일시적으로 숨김.\u003Cbr\u003E(working tree의 변경내용을 commit하기 싫을 때)\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit pull\u003C\u002Fcode\u003E: \u003Ccode\u003Egit fetch\u003C\u002Fcode\u003E + \u003Ccode\u003Egit merge FETCH_HEAD\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Eorigin\u003C\u002Fcode\u003E: 원격 저장소를 의미함.\u003C\u002Fp\u003E\n\u003Ch2 id=\"하나의-컴퓨터local-machine에서-다중-user를-이용한-github-작업-수정-중\"\u003E하나의 컴퓨터(local machine)에서 다중 User를 이용한 github 작업. (수정 중)\u003Ca href=\"#하나의-컴퓨터local-machine에서-다중-user를-이용한-github-작업-수정-중\" class=\"anchor\"\u003E\u003Cspan class=\"visually-hidden\"\u003E#\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\u003Cp\u003E(SSH key 를 사용한다는 가정을 둔다. SSH key (= public key)는 보안을 올려주는 중요한 기능이다. 굳이 Github가 아니더라도 remote 접속시 보안을 지킬 수 있다.)\u003C\u002Fp\u003E\n\u003Cp\u003EGitHub 작업 시에 개인 계정과 회사 계정이 있을 경우 \u003Ccode\u003Egit\u003C\u002Fcode\u003E 작업이 다소 복잡해진다. 우선 \u003Ccode\u003Egit clone\u003C\u002Fcode\u003E 부터 문제가 생긴다.\u003C\u002Fp\u003E\n\u003Cp\u003EGitHub 는 계정당 하나의 ssh-key를 가지게 된다. 서로 다른 User가 동일한 ssh-key를 가질 수 없다. User 별로 ssh-key가 필요하다.\u003C\u002Fp\u003E\n\u003Cp\u003E본 글은 \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002FJoaquimLey\u002Fe6049a12c8fd2923611802384cd2fb4a\"\u003EJoaquimLey의 github_multiple-accounts.md\u003C\u002Fa\u003E와 \u003Ca href=\"https:\u002F\u002Fdocs.github.com\u002Fen\u002Fgithub\u002Fauthenticating-to-github\u002Fgenerating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\"\u003Egithub docs\u003C\u002Fa\u003E를 참조했다.\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E각 GitHub 계정 별 ssh-key를 생성한다. \u003Ccode\u003Essh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;\u003C\u002Fcode\u003E (여기서 \u003Ccode\u003E-t\u003C\u002Fcode\u003E는 rsa 방식을 이용하며, \u003Ccode\u003E-b\u003C\u002Fcode\u003E는 4096 bit의 key를 생성하며, \u003Ccode\u003E-C\u003C\u002Fcode\u003E는 “\u003Ca href=\"mailto:&#x79;&#x6f;&#x75;&#x72;&#x5f;&#x65;&#109;&#x61;&#x69;&#108;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;\"\u003E&#x79;&#x6f;&#x75;&#x72;&#x5f;&#x65;&#109;&#x61;&#x69;&#108;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;\u003C\u002Fa\u003E“의 comment를 추가하겠다는 얘기이다. 기본은 rsa에 2048 bit 의 key가 생성된다.)\u003Cbr\u003E만약 기존의 \u003Ccode\u003E~\u002F.ssh\u002Fid_rsa\u003C\u002Fcode\u003E 가 존재하면, \u003Ccode\u003Essh-keygen -f ~\u002F.ssh\u002Fid_rsa_COMPANY\u003C\u002Fcode\u003E로 다른 이름을 명명해준다.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E기본 위치인 \u003Ccode\u003E\u002Fhome\u002F$USER\u002F.ssh\u002Fid_rsa\u003C\u002Fcode\u003E에 저장을 해주고, passphrase를 입력해준다. \u003Ccode\u003Epassphrase\u003C\u002Fcode\u003E는 문장형 비밀번호이다. 공백 포함이 가능하다. (ex. \u003Ccode\u003E이것은 문장형 비밀번호\u003C\u002Fcode\u003E; \u003Cdel\u003E한글을 영어로 입력을 해주면 보안성이 매우 좋다.. 한국인만 가능하다\u003C\u002Fdel\u003E)\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Eeval &quot;$(ssh-agent -s)&quot;\u003C\u002Fcode\u003E ssh-agent를 불러온다. terminal 시작 시 자동으로 불러올 수 있다. (추가 예정)\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Essh-add ~\u002F.ssh\u002Fid_rsa_*\u003C\u002Fcode\u003E로 key를 agent에 추가하면 된다. (사용하고자 하는 key를 불러오면 된다.)\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E~\u002F.ssh\u002Fconfig\u003C\u002Fcode\u003E 파일에 github ssh config 정보를 추가한다.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cdiv class=\"code-block bash\"\u003E\u003Cpre class='language-bash'\u003E\u003Ccode\u003EHost github-my\n    Hostname github.com\n    User \u003Cspan class=\"token function\"\u003Egit\u003C\u002Fspan\u003E\n    IdentityFile ~\u002F.ssh\u002Fid_rsa_MY\n    ForwardAgent \u003Cspan class=\"token function\"\u003Eyes\u003C\u002Fspan\u003E\n\nHost github-company\n    Hostname github.com\n    User \u003Cspan class=\"token function\"\u003Egit\u003C\u002Fspan\u003E\n    IdentityFile ~\u002F.ssh\u002Fid_rsa_COMPANY\n    ForwardAgent \u003Cspan class=\"token function\"\u003Eyes\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Col start=\"6\"\u003E\n\u003Cli\u003E\u003Ccode\u003Essh -T github-my\u003C\u002Fcode\u003E 와 \u003Ccode\u003Essh -T github-company\u003C\u002Fcode\u003E를 모두 사용하여 서로 다른 User name이 나오는지 확인한다. 목적에 맞는 User name 이 등장하면 성공! 같은 이름이 등장하면 사용된 key가 제대로 설정되지 않은 것이다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Egit clone github-my:MY-ID\u002FMY-REPO.git\u003C\u002Fcode\u003E 와 같이 불러오면 된다.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"],"uses":{"params":["path","slug"]}}]}
